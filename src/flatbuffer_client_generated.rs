// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod buttplug_ffi {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u16)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum DeviceCommunicationManagerTypes {
  Btleplug = 1,
  XInput = 2,
  SerialPort = 4,
  LovenseHIDDongle = 8,
  LovenseSerialDongle = 16,

}

pub const ENUM_MIN_DEVICE_COMMUNICATION_MANAGER_TYPES: u16 = 1;
pub const ENUM_MAX_DEVICE_COMMUNICATION_MANAGER_TYPES: u16 = 16;

impl<'a> flatbuffers::Follow<'a> for DeviceCommunicationManagerTypes {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for DeviceCommunicationManagerTypes {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u16::to_le(self as u16);
    let p = &n as *const u16 as *const DeviceCommunicationManagerTypes;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u16::from_le(self as u16);
    let p = &n as *const u16 as *const DeviceCommunicationManagerTypes;
    unsafe { *p }
  }
}

impl flatbuffers::Push for DeviceCommunicationManagerTypes {
    type Output = DeviceCommunicationManagerTypes;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<DeviceCommunicationManagerTypes>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DEVICE_COMMUNICATION_MANAGER_TYPES:[DeviceCommunicationManagerTypes; 5] = [
  DeviceCommunicationManagerTypes::Btleplug,
  DeviceCommunicationManagerTypes::XInput,
  DeviceCommunicationManagerTypes::SerialPort,
  DeviceCommunicationManagerTypes::LovenseHIDDongle,
  DeviceCommunicationManagerTypes::LovenseSerialDongle
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_DEVICE_COMMUNICATION_MANAGER_TYPES:[&'static str; 16] = [
    "Btleplug",
    "XInput",
    "",
    "SerialPort",
    "",
    "",
    "",
    "LovenseHIDDongle",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "LovenseSerialDongle"
];

pub fn enum_name_device_communication_manager_types(e: DeviceCommunicationManagerTypes) -> &'static str {
  let index = e as u16 - DeviceCommunicationManagerTypes::Btleplug as u16;
  ENUM_NAMES_DEVICE_COMMUNICATION_MANAGER_TYPES[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum ClientMessageType {
  NONE = 0,
  ConnectLocal = 1,
  ConnectWebsocket = 2,
  StartScanning = 3,
  StopScanning = 4,
  RequestDeviceList = 5,

}

pub const ENUM_MIN_CLIENT_MESSAGE_TYPE: u8 = 0;
pub const ENUM_MAX_CLIENT_MESSAGE_TYPE: u8 = 5;

impl<'a> flatbuffers::Follow<'a> for ClientMessageType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for ClientMessageType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const ClientMessageType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const ClientMessageType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for ClientMessageType {
    type Output = ClientMessageType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<ClientMessageType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CLIENT_MESSAGE_TYPE:[ClientMessageType; 6] = [
  ClientMessageType::NONE,
  ClientMessageType::ConnectLocal,
  ClientMessageType::ConnectWebsocket,
  ClientMessageType::StartScanning,
  ClientMessageType::StopScanning,
  ClientMessageType::RequestDeviceList
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_CLIENT_MESSAGE_TYPE:[&'static str; 6] = [
    "NONE",
    "ConnectLocal",
    "ConnectWebsocket",
    "StartScanning",
    "StopScanning",
    "RequestDeviceList"
];

pub fn enum_name_client_message_type(e: ClientMessageType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_CLIENT_MESSAGE_TYPE[index as usize]
}

pub struct ClientMessageTypeUnionTableOffset {}
pub enum ConnectLocalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ConnectLocal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConnectLocal<'a> {
    type Inner = ConnectLocal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ConnectLocal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConnectLocal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConnectLocalArgs<'args>) -> flatbuffers::WIPOffset<ConnectLocal<'bldr>> {
      let mut builder = ConnectLocalBuilder::new(_fbb);
      builder.add_max_ping_time(args.max_ping_time);
      if let Some(x) = args.server_name { builder.add_server_name(x); }
      builder.add_comm_manager_types(args.comm_manager_types);
      builder.finish()
    }

    pub const VT_SERVER_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_MAX_PING_TIME: flatbuffers::VOffsetT = 6;
    pub const VT_COMM_MANAGER_TYPES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn server_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConnectLocal::VT_SERVER_NAME, None)
  }
  #[inline]
  pub fn max_ping_time(&self) -> u32 {
    self._tab.get::<u32>(ConnectLocal::VT_MAX_PING_TIME, Some(0)).unwrap()
  }
  #[inline]
  pub fn comm_manager_types(&self) -> u16 {
    self._tab.get::<u16>(ConnectLocal::VT_COMM_MANAGER_TYPES, Some(0)).unwrap()
  }
}

pub struct ConnectLocalArgs<'a> {
    pub server_name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub max_ping_time: u32,
    pub comm_manager_types: u16,
}
impl<'a> Default for ConnectLocalArgs<'a> {
    #[inline]
    fn default() -> Self {
        ConnectLocalArgs {
            server_name: None,
            max_ping_time: 0,
            comm_manager_types: 0,
        }
    }
}
pub struct ConnectLocalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConnectLocalBuilder<'a, 'b> {
  #[inline]
  pub fn add_server_name(&mut self, server_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConnectLocal::VT_SERVER_NAME, server_name);
  }
  #[inline]
  pub fn add_max_ping_time(&mut self, max_ping_time: u32) {
    self.fbb_.push_slot::<u32>(ConnectLocal::VT_MAX_PING_TIME, max_ping_time, 0);
  }
  #[inline]
  pub fn add_comm_manager_types(&mut self, comm_manager_types: u16) {
    self.fbb_.push_slot::<u16>(ConnectLocal::VT_COMM_MANAGER_TYPES, comm_manager_types, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConnectLocalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConnectLocalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConnectLocal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ConnectWebsocketOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ConnectWebsocket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConnectWebsocket<'a> {
    type Inner = ConnectWebsocket<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ConnectWebsocket<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConnectWebsocket {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ConnectWebsocketArgs) -> flatbuffers::WIPOffset<ConnectWebsocket<'bldr>> {
      let mut builder = ConnectWebsocketBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct ConnectWebsocketArgs {
}
impl<'a> Default for ConnectWebsocketArgs {
    #[inline]
    fn default() -> Self {
        ConnectWebsocketArgs {
        }
    }
}
pub struct ConnectWebsocketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConnectWebsocketBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConnectWebsocketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConnectWebsocketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConnectWebsocket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StartScanningOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StartScanning<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StartScanning<'a> {
    type Inner = StartScanning<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StartScanning<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StartScanning {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args StartScanningArgs) -> flatbuffers::WIPOffset<StartScanning<'bldr>> {
      let mut builder = StartScanningBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct StartScanningArgs {
}
impl<'a> Default for StartScanningArgs {
    #[inline]
    fn default() -> Self {
        StartScanningArgs {
        }
    }
}
pub struct StartScanningBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StartScanningBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StartScanningBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StartScanningBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StartScanning<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StopScanningOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StopScanning<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StopScanning<'a> {
    type Inner = StopScanning<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StopScanning<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StopScanning {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args StopScanningArgs) -> flatbuffers::WIPOffset<StopScanning<'bldr>> {
      let mut builder = StopScanningBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct StopScanningArgs {
}
impl<'a> Default for StopScanningArgs {
    #[inline]
    fn default() -> Self {
        StopScanningArgs {
        }
    }
}
pub struct StopScanningBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StopScanningBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StopScanningBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StopScanningBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StopScanning<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RequestDeviceListOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RequestDeviceList<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RequestDeviceList<'a> {
    type Inner = RequestDeviceList<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RequestDeviceList<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RequestDeviceList {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args RequestDeviceListArgs) -> flatbuffers::WIPOffset<RequestDeviceList<'bldr>> {
      let mut builder = RequestDeviceListBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct RequestDeviceListArgs {
}
impl<'a> Default for RequestDeviceListArgs {
    #[inline]
    fn default() -> Self {
        RequestDeviceListArgs {
        }
    }
}
pub struct RequestDeviceListBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RequestDeviceListBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RequestDeviceListBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RequestDeviceListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RequestDeviceList<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ClientMessageOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ClientMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClientMessage<'a> {
    type Inner = ClientMessage<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ClientMessage<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ClientMessage {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ClientMessageArgs) -> flatbuffers::WIPOffset<ClientMessage<'bldr>> {
      let mut builder = ClientMessageBuilder::new(_fbb);
      if let Some(x) = args.message { builder.add_message(x); }
      builder.add_id(args.id);
      builder.add_message_type(args.message_type);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(ClientMessage::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn message_type(&self) -> ClientMessageType {
    self._tab.get::<ClientMessageType>(ClientMessage::VT_MESSAGE_TYPE, Some(ClientMessageType::NONE)).unwrap()
  }
  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ClientMessage::VT_MESSAGE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_connect_local(&self) -> Option<ConnectLocal<'a>> {
    if self.message_type() == ClientMessageType::ConnectLocal {
      self.message().map(|u| ConnectLocal::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_connect_websocket(&self) -> Option<ConnectWebsocket<'a>> {
    if self.message_type() == ClientMessageType::ConnectWebsocket {
      self.message().map(|u| ConnectWebsocket::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_start_scanning(&self) -> Option<StartScanning<'a>> {
    if self.message_type() == ClientMessageType::StartScanning {
      self.message().map(|u| StartScanning::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_stop_scanning(&self) -> Option<StopScanning<'a>> {
    if self.message_type() == ClientMessageType::StopScanning {
      self.message().map(|u| StopScanning::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_request_device_list(&self) -> Option<RequestDeviceList<'a>> {
    if self.message_type() == ClientMessageType::RequestDeviceList {
      self.message().map(|u| RequestDeviceList::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct ClientMessageArgs {
    pub id: u32,
    pub message_type: ClientMessageType,
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ClientMessageArgs {
    #[inline]
    fn default() -> Self {
        ClientMessageArgs {
            id: 0,
            message_type: ClientMessageType::NONE,
            message: None,
        }
    }
}
pub struct ClientMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ClientMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(ClientMessage::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_message_type(&mut self, message_type: ClientMessageType) {
    self.fbb_.push_slot::<ClientMessageType>(ClientMessage::VT_MESSAGE_TYPE, message_type, ClientMessageType::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientMessage::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ClientMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ClientMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClientMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_client_message<'a>(buf: &'a [u8]) -> ClientMessage<'a> {
  flatbuffers::get_root::<ClientMessage<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_client_message<'a>(buf: &'a [u8]) -> ClientMessage<'a> {
  flatbuffers::get_size_prefixed_root::<ClientMessage<'a>>(buf)
}

#[inline]
pub fn finish_client_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<ClientMessage<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_client_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<ClientMessage<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod ButtplugFFI

