// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod ffi {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum DeviceCommunicationManagerTypes {
  Btleplug = 0,
  XInput = 1,
  SerialPort = 2,
  LovenseHIDDongle = 3,
  LovenseSerialDongle = 4,

}

pub const ENUM_MIN_DEVICE_COMMUNICATION_MANAGER_TYPES: i8 = 0;
pub const ENUM_MAX_DEVICE_COMMUNICATION_MANAGER_TYPES: i8 = 4;

impl<'a> flatbuffers::Follow<'a> for DeviceCommunicationManagerTypes {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for DeviceCommunicationManagerTypes {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const DeviceCommunicationManagerTypes;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const DeviceCommunicationManagerTypes;
    unsafe { *p }
  }
}

impl flatbuffers::Push for DeviceCommunicationManagerTypes {
    type Output = DeviceCommunicationManagerTypes;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<DeviceCommunicationManagerTypes>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DEVICE_COMMUNICATION_MANAGER_TYPES:[DeviceCommunicationManagerTypes; 5] = [
  DeviceCommunicationManagerTypes::Btleplug,
  DeviceCommunicationManagerTypes::XInput,
  DeviceCommunicationManagerTypes::SerialPort,
  DeviceCommunicationManagerTypes::LovenseHIDDongle,
  DeviceCommunicationManagerTypes::LovenseSerialDongle
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_DEVICE_COMMUNICATION_MANAGER_TYPES:[&'static str; 5] = [
    "Btleplug",
    "XInput",
    "SerialPort",
    "LovenseHIDDongle",
    "LovenseSerialDongle"
];

pub fn enum_name_device_communication_manager_types(e: DeviceCommunicationManagerTypes) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_DEVICE_COMMUNICATION_MANAGER_TYPES[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum ClientMessage {
  NONE = 0,
  ConnectLocal = 1,
  ConnectWebsocket = 2,
  StartScanning = 3,
  StopScanning = 4,
  RequestDeviceList = 5,

}

pub const ENUM_MIN_CLIENT_MESSAGE: u8 = 0;
pub const ENUM_MAX_CLIENT_MESSAGE: u8 = 5;

impl<'a> flatbuffers::Follow<'a> for ClientMessage {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for ClientMessage {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const ClientMessage;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const ClientMessage;
    unsafe { *p }
  }
}

impl flatbuffers::Push for ClientMessage {
    type Output = ClientMessage;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<ClientMessage>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CLIENT_MESSAGE:[ClientMessage; 6] = [
  ClientMessage::NONE,
  ClientMessage::ConnectLocal,
  ClientMessage::ConnectWebsocket,
  ClientMessage::StartScanning,
  ClientMessage::StopScanning,
  ClientMessage::RequestDeviceList
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_CLIENT_MESSAGE:[&'static str; 6] = [
    "NONE",
    "ConnectLocal",
    "ConnectWebsocket",
    "StartScanning",
    "StopScanning",
    "RequestDeviceList"
];

pub fn enum_name_client_message(e: ClientMessage) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_CLIENT_MESSAGE[index as usize]
}

pub struct ClientMessageUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum ServerMessage {
  NONE = 0,
  Ok = 1,
  Error = 2,
  ScanningFinished = 3,
  DeviceList = 4,
  DeviceAdded = 5,
  DeviceRemoved = 6,

}

pub const ENUM_MIN_SERVER_MESSAGE: u8 = 0;
pub const ENUM_MAX_SERVER_MESSAGE: u8 = 6;

impl<'a> flatbuffers::Follow<'a> for ServerMessage {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for ServerMessage {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const ServerMessage;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const ServerMessage;
    unsafe { *p }
  }
}

impl flatbuffers::Push for ServerMessage {
    type Output = ServerMessage;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<ServerMessage>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SERVER_MESSAGE:[ServerMessage; 7] = [
  ServerMessage::NONE,
  ServerMessage::Ok,
  ServerMessage::Error,
  ServerMessage::ScanningFinished,
  ServerMessage::DeviceList,
  ServerMessage::DeviceAdded,
  ServerMessage::DeviceRemoved
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_SERVER_MESSAGE:[&'static str; 7] = [
    "NONE",
    "Ok",
    "Error",
    "ScanningFinished",
    "DeviceList",
    "DeviceAdded",
    "DeviceRemoved"
];

pub fn enum_name_server_message(e: ServerMessage) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_SERVER_MESSAGE[index as usize]
}

pub struct ServerMessageUnionTableOffset {}
pub enum CreateClientOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CreateClient<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateClient<'a> {
    type Inner = CreateClient<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CreateClient<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CreateClient {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CreateClientArgs<'args>) -> flatbuffers::WIPOffset<CreateClient<'bldr>> {
      let mut builder = CreateClientBuilder::new(_fbb);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.finish()
    }

    pub const VT_NAME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreateClient::VT_NAME, None)
  }
}

pub struct CreateClientArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for CreateClientArgs<'a> {
    #[inline]
    fn default() -> Self {
        CreateClientArgs {
            name: None,
        }
    }
}
pub struct CreateClientBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CreateClientBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateClient::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CreateClientBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CreateClientBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateClient<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ConnectLocalOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ConnectLocal<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConnectLocal<'a> {
    type Inner = ConnectLocal<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ConnectLocal<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConnectLocal {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConnectLocalArgs) -> flatbuffers::WIPOffset<ConnectLocal<'bldr>> {
      let mut builder = ConnectLocalBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(ConnectLocal::VT_ID, Some(0)).unwrap()
  }
}

pub struct ConnectLocalArgs {
    pub id: u32,
}
impl<'a> Default for ConnectLocalArgs {
    #[inline]
    fn default() -> Self {
        ConnectLocalArgs {
            id: 0,
        }
    }
}
pub struct ConnectLocalBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConnectLocalBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(ConnectLocal::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConnectLocalBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConnectLocalBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConnectLocal<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ConnectWebsocketOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ConnectWebsocket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConnectWebsocket<'a> {
    type Inner = ConnectWebsocket<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ConnectWebsocket<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ConnectWebsocket {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ConnectWebsocketArgs) -> flatbuffers::WIPOffset<ConnectWebsocket<'bldr>> {
      let mut builder = ConnectWebsocketBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(ConnectWebsocket::VT_ID, Some(0)).unwrap()
  }
}

pub struct ConnectWebsocketArgs {
    pub id: u32,
}
impl<'a> Default for ConnectWebsocketArgs {
    #[inline]
    fn default() -> Self {
        ConnectWebsocketArgs {
            id: 0,
        }
    }
}
pub struct ConnectWebsocketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConnectWebsocketBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(ConnectWebsocket::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConnectWebsocketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConnectWebsocketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConnectWebsocket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StartScanningOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StartScanning<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StartScanning<'a> {
    type Inner = StartScanning<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StartScanning<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StartScanning {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StartScanningArgs) -> flatbuffers::WIPOffset<StartScanning<'bldr>> {
      let mut builder = StartScanningBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(StartScanning::VT_ID, Some(0)).unwrap()
  }
}

pub struct StartScanningArgs {
    pub id: u32,
}
impl<'a> Default for StartScanningArgs {
    #[inline]
    fn default() -> Self {
        StartScanningArgs {
            id: 0,
        }
    }
}
pub struct StartScanningBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StartScanningBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(StartScanning::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StartScanningBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StartScanningBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StartScanning<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum StopScanningOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StopScanning<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StopScanning<'a> {
    type Inner = StopScanning<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StopScanning<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StopScanning {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StopScanningArgs) -> flatbuffers::WIPOffset<StopScanning<'bldr>> {
      let mut builder = StopScanningBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(StopScanning::VT_ID, Some(0)).unwrap()
  }
}

pub struct StopScanningArgs {
    pub id: u32,
}
impl<'a> Default for StopScanningArgs {
    #[inline]
    fn default() -> Self {
        StopScanningArgs {
            id: 0,
        }
    }
}
pub struct StopScanningBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StopScanningBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(StopScanning::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StopScanningBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StopScanningBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StopScanning<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RequestDeviceListOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RequestDeviceList<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RequestDeviceList<'a> {
    type Inner = RequestDeviceList<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RequestDeviceList<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RequestDeviceList {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RequestDeviceListArgs) -> flatbuffers::WIPOffset<RequestDeviceList<'bldr>> {
      let mut builder = RequestDeviceListBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(RequestDeviceList::VT_ID, Some(0)).unwrap()
  }
}

pub struct RequestDeviceListArgs {
    pub id: u32,
}
impl<'a> Default for RequestDeviceListArgs {
    #[inline]
    fn default() -> Self {
        RequestDeviceListArgs {
            id: 0,
        }
    }
}
pub struct RequestDeviceListBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RequestDeviceListBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(RequestDeviceList::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RequestDeviceListBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RequestDeviceListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RequestDeviceList<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OkOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Ok<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Ok<'a> {
    type Inner = Ok<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Ok<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Ok {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OkArgs) -> flatbuffers::WIPOffset<Ok<'bldr>> {
      let mut builder = OkBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(Ok::VT_ID, Some(0)).unwrap()
  }
}

pub struct OkArgs {
    pub id: u32,
}
impl<'a> Default for OkArgs {
    #[inline]
    fn default() -> Self {
        OkArgs {
            id: 0,
        }
    }
}
pub struct OkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OkBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Ok::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Ok<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ErrorOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Error<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Error<'a> {
    type Inner = Error<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Error<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Error {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ErrorArgs) -> flatbuffers::WIPOffset<Error<'bldr>> {
      let mut builder = ErrorBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(Error::VT_ID, Some(0)).unwrap()
  }
}

pub struct ErrorArgs {
    pub id: u32,
}
impl<'a> Default for ErrorArgs {
    #[inline]
    fn default() -> Self {
        ErrorArgs {
            id: 0,
        }
    }
}
pub struct ErrorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ErrorBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(Error::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ErrorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ErrorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Error<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ScanningFinishedOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ScanningFinished<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScanningFinished<'a> {
    type Inner = ScanningFinished<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ScanningFinished<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ScanningFinished {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ScanningFinishedArgs) -> flatbuffers::WIPOffset<ScanningFinished<'bldr>> {
      let mut builder = ScanningFinishedBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(ScanningFinished::VT_ID, Some(0)).unwrap()
  }
}

pub struct ScanningFinishedArgs {
    pub id: u32,
}
impl<'a> Default for ScanningFinishedArgs {
    #[inline]
    fn default() -> Self {
        ScanningFinishedArgs {
            id: 0,
        }
    }
}
pub struct ScanningFinishedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScanningFinishedBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(ScanningFinished::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ScanningFinishedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ScanningFinishedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScanningFinished<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DeviceListOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DeviceList<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeviceList<'a> {
    type Inner = DeviceList<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DeviceList<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DeviceList {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DeviceListArgs) -> flatbuffers::WIPOffset<DeviceList<'bldr>> {
      let mut builder = DeviceListBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(DeviceList::VT_ID, Some(0)).unwrap()
  }
}

pub struct DeviceListArgs {
    pub id: u32,
}
impl<'a> Default for DeviceListArgs {
    #[inline]
    fn default() -> Self {
        DeviceListArgs {
            id: 0,
        }
    }
}
pub struct DeviceListBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DeviceListBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(DeviceList::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DeviceListBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DeviceListBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DeviceList<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DeviceAddedOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DeviceAdded<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeviceAdded<'a> {
    type Inner = DeviceAdded<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DeviceAdded<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DeviceAdded {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DeviceAddedArgs) -> flatbuffers::WIPOffset<DeviceAdded<'bldr>> {
      let mut builder = DeviceAddedBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(DeviceAdded::VT_ID, Some(0)).unwrap()
  }
}

pub struct DeviceAddedArgs {
    pub id: u32,
}
impl<'a> Default for DeviceAddedArgs {
    #[inline]
    fn default() -> Self {
        DeviceAddedArgs {
            id: 0,
        }
    }
}
pub struct DeviceAddedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DeviceAddedBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(DeviceAdded::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DeviceAddedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DeviceAddedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DeviceAdded<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DeviceRemovedOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DeviceRemoved<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeviceRemoved<'a> {
    type Inner = DeviceRemoved<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DeviceRemoved<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DeviceRemoved {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DeviceRemovedArgs) -> flatbuffers::WIPOffset<DeviceRemoved<'bldr>> {
      let mut builder = DeviceRemovedBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u32 {
    self._tab.get::<u32>(DeviceRemoved::VT_ID, Some(0)).unwrap()
  }
}

pub struct DeviceRemovedArgs {
    pub id: u32,
}
impl<'a> Default for DeviceRemovedArgs {
    #[inline]
    fn default() -> Self {
        DeviceRemovedArgs {
            id: 0,
        }
    }
}
pub struct DeviceRemovedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DeviceRemovedBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u32) {
    self.fbb_.push_slot::<u32>(DeviceRemoved::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DeviceRemovedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DeviceRemovedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DeviceRemoved<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod ffi

